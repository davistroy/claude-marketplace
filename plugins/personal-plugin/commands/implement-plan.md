---
description: Execute IMPLEMENTATION_PLAN.md using orchestrated subagents with automatic testing, documentation, and git workflow
allowed-tools: Agent, Bash(git:*), Bash(gh:*), Bash(npm:*), Bash(npx:*), Bash(yarn:*), Bash(pnpm:*), Bash(pytest:*), Bash(python:*), Bash(jest:*), Bash(vitest:*), Bash(bun:*), Task
---

# Implement Plan Command

Execute an IMPLEMENTATION_PLAN.md file by orchestrating subagents in a loop. Each work item is implemented, tested, documented, and committed by dedicated subagents while the main agent retains only minimal state — preserving context window capacity for long-running plans.

## Input Validation

**Optional Arguments:**

| Argument | Default | Description |
|----------|---------|-------------|
| `--input <path>` | `IMPLEMENTATION_PLAN.md` | Path to the plan file. Supports absolute or relative paths. Use this when the plan was generated to a non-default location (e.g., `/create-plan --output docs/plan.md`). |
| `--auto-merge` | `false` | When set, automatically merge the PR and clean up the branch after all work items are complete. Without this flag, the command creates a PR and stops. |
| `--pause-between-phases` | `false` | When set, pause and ask the user for confirmation before starting each new phase. Useful for reviewing progress or adjusting the plan mid-execution. |
| `--progress` | `false` | When set, generate/update PROGRESS.md even if it does not already exist. By default, PROGRESS.md is only updated if it already exists in the repo (to avoid creating tracking files that duplicate `git log`). |

**Argument Resolution:**

At startup, resolve the plan file path:
1. If `--input <path>` was provided, use that path (resolve relative paths against the repository root)
2. Otherwise, default to `IMPLEMENTATION_PLAN.md` in the repository root
3. Store the resolved path as `PLAN_FILE` — use this variable in ALL subsequent references to the plan file

**Prerequisites Validation:**

Before executing the plan, verify:
1. `PLAN_FILE` exists at the resolved path
2. Current branch is NOT main or master
3. Working directory is clean (no uncommitted changes)
4. GitHub CLI (gh) is authenticated

**If the plan file is missing:**
```text
Error: [PLAN_FILE] not found.

Run one of these commands to generate an implementation plan:
- /plan-improvements — Generate from codebase analysis
- /create-plan — Generate from requirements documents

Or specify a custom path: /implement-plan --input <path-to-plan>
```

**If on main/master:**
```text
Error: Cannot run on main/master branch.

Create a feature branch first:
  git checkout -b feature/implementation
```

**If working directory is dirty:**

Check if `.implement-plan-state.json` exists and contains an `"in_progress"` or `"in_progress_batch"` field. If so, the dirty state is likely from an interrupted implementation session:

```text
Uncommitted changes detected. State file shows work item [X.Y] was in progress.
This may be leftover from an interrupted session.

Options:
  (1) Commit these changes and resume (git add + commit as "[X.Y] interrupted work")
  (2) Stash these changes and resume (git stash)
  (3) Abort — inspect manually first
```

Wait for the user's choice and execute accordingly before proceeding.

If there is NO state file or no IN_PROGRESS item, use the standard error:
```text
Error: Uncommitted changes detected.

Commit or stash your changes before running this command:
  git status
  git add <files> && git commit -m "Message"
```

## Overview

This command automates the execution of a phased implementation plan by:

1. Reading the plan and tracking progress
2. Implementing each work item via subagents (with project context for orientation)
3. Running tests and fixing failures
4. Optionally updating PROGRESS.md (if it exists) and LEARNINGS.md (only when tests had issues)
5. Committing after each work item
6. Creating a PR when complete (merge only with `--auto-merge`)

## Prerequisites

Before running this command, ensure:

- **Plan file** exists at the expected path (default: `IMPLEMENTATION_PLAN.md` in repo root, or custom path via `--input`). Generated by `/plan-improvements` or `/create-plan`.
- You are on a feature branch (not main/master)
- Working directory is clean (no uncommitted changes)
- GitHub CLI (gh) is authenticated

## Execution Strategy

### Context Window Discipline

**This is the most important principle.** Large plans can span dozens of work items. If the main agent reads files, holds implementation details, or accumulates subagent output, the context window fills up and the agent loses coherence before the plan completes.

**Rules:**

| Do | Do Not |
|----|--------|
| Delegate ALL file reading to subagents | Read the plan file or source files directly |
| Retain only: status, files changed, errors | Ask subagents to return file contents |
| Use `.implement-plan-state.json` as the sole source of truth | Accumulate work item status in conversational memory |
| Use TaskCreate/TaskUpdate for progress tracking (not subagent launching) | Hold work item details in conversational memory |
| Spawn fresh subagents for each step | Reuse subagent context across work items |
| Launch parallel subagents with `run_in_background: true` | Wait for one item to finish before starting an independent one |
| Fold plan-file updates into implementation subagent | Spawn a separate doc subagent for every work item |
| Use a single commit for parallel batches | Create individual commits for each parallel item |
| Shed old subagent summaries every 5 items | Keep all iteration results in conversation history |

### State File (`.implement-plan-state.json`)

The state file is the **ground truth** for execution progress. It persists minimal state between loop iterations so the main agent never needs to re-read the full plan or accumulate conversational history.

**Format:**

```json
{
  "plan_file": "IMPLEMENTATION_PLAN.md",
  "started_at": "2026-02-28T14:30:00",
  "current_phase": "Phase 3: Context Window Management",
  "current_item": "3.2",
  "in_progress": {
    "item": "3.2",
    "phase": "Phase 3",
    "description": "Restructure implement-plan loop",
    "started_at": "2026-02-28T15:42:00"
  },
  "completed": [
    { "item": "1.1", "phase": "Phase 1", "description": "Add Tasks and Notes fields", "status": "COMPLETE", "sha": "abc1234", "files": ["plan-improvements.md"] },
    { "item": "1.2", "phase": "Phase 1", "description": "Standardize headers", "status": "COMPLETE", "sha": "def5678", "files": ["plan-improvements.md", "create-plan.md"] }
  ],
  "failed": [
    { "item": "2.3", "phase": "Phase 2", "description": "Update allowed-tools", "error": "Test failure in...", "attempts": 2 }
  ],
  "project_context": {
    "project_description": "React dashboard app with REST API backend",
    "tech_stack": "TypeScript, React, Jest",
    "test_command": "npm test",
    "conventions": "kebab-case files, ESM imports"
  },
  "last_good_sha": "def5678",
  "checkpoints": {
    "1.1": "abc1234",
    "1.2": "def5678"
  },
  "parallelization_map": {
    "Phase 1": { "parallel": ["1.1", "1.2"], "sequential": ["1.3", "1.4"] },
    "Phase 2": { "parallel": ["2.1", "2.2", "2.3"], "sequential": ["2.4"] }
  }
}
```

**Note on `in_progress` field:** This field is present only while a work item is being actively implemented. It is set in Step A0/B0 (before implementation) and removed in Step A5/B6 (after commit). On resume, if this field exists, it indicates an interrupted session — the resume logic in Step 0 handles this case.

**State file rules:**
- Created during STARTUP, updated after every work item completion
- Updated BEFORE implementation starts (mark item IN_PROGRESS) and AFTER commit succeeds (mark item COMPLETE, clear `in_progress`)
- Added to `.gitignore` (ephemeral execution state, not a project artifact)
- If the state file exists at STARTUP, resume from where it left off instead of re-reading the full plan
- If resume detects an `in_progress` entry, offer the user retry/skip/complete options before continuing
- The main agent reads this file directly (it is small and structured) — no subagent needed
- Delete the state file during FINALIZATION after the PR is created

### State Shedding

**After every 5 completed work items**, actively shed accumulated conversational state:

1. The state file contains everything needed to continue — do NOT rely on earlier conversation history
2. Mentally discard all previous subagent summaries, file lists, and error details from prior iterations
3. For the next iteration, derive the work item and context exclusively from the state file
4. The only conversational state to retain is: (a) the `PLAN_FILE` path, (b) user-provided flags (`--auto-merge`, `--pause-between-phases`), (c) the state file path

### Orchestration Pattern

The main agent acts as a **thin loop controller** — it decides what to do next, spawns subagents to do it, records outcomes in 1-2 sentences, and moves on. All heavy lifting (reading files, writing code, running tests, updating docs) happens inside subagents whose context is discarded after they return.

**Parallel-first execution:** When the plan marks work items as parallelizable (same phase, no inter-dependencies), launch multiple implementation subagents concurrently using `run_in_background: true`. This dramatically reduces total execution time.

### Workflow Per Work Item

For each incomplete work item in the plan file (`PLAN_FILE`):

1. **Implementation Subagent**: Reads the plan, implements the work item, and marks it complete in `PLAN_FILE` (includes project context for orientation)
2. **Testing Subagent**: Runs all tests, fixes failures until all pass
3. **Main Agent**: Optionally updates PROGRESS.md (if it exists) and LEARNINGS.md (if tests had issues), then commits and pushes

**Parallel variant** (for independent work items within the same phase):

1. **Launch N implementation subagents concurrently** (one per independent work item, `run_in_background: true`) — each updates `PLAN_FILE` for its own item
2. **Collect results** as each completes — check output files for status
3. **Single testing subagent** runs full test suite after all parallel items complete
4. **Main Agent**: Optionally updates PROGRESS.md and LEARNINGS.md, then single commit covering all parallel work items, then push

### Finalization

When all work items are complete:

1. Polish all documentation
2. Create PR with title "Implementation Complete"
3. Merge PR and clean up branch

## Instructions

Follow these steps exactly. Use the **Agent tool** to spawn subagents (with `subagent_type: "general-purpose"` and `prompt: "..."`). Use **TaskCreate/TaskUpdate/TaskList** only for progress tracking — they do NOT launch subagents. After each subagent returns, retain only the minimal summary described — discard everything else.

### STARTUP (do this ONCE at the beginning)

**Step 0: Check for existing state file (resume support)**

Check if `.implement-plan-state.json` exists in the repository root. Read it directly (it is small JSON — no subagent needed).

- **If the state file does not exist or is corrupted:** Continue with Step 1 below.
- **If the state file exists and is valid:** Resume execution. Skip the STARTUP subagent. Read `current_phase`, `current_item`, `completed`, `failed`, and `parallelization_map` from the state file.

  **Check for interrupted work items (IN_PROGRESS detection):**

  Check if the state file contains an `"in_progress"` field (sequential item) or `"in_progress_batch"` field (parallel items). These fields are set in Step A0/B0 before implementation and cleared in Step A5/B6 after commit. If either field is present, an item was interrupted mid-implementation:

  ```text
  Resuming from interrupted session. [N] items already completed.
  Work item [X.Y] ("[description]") was in progress when the previous session ended.

  Options:
    (1) Retry — re-implement this work item from scratch
    (2) Skip — mark as skipped and move to the next item
    (3) Mark complete — the work was finished but not recorded; mark it done and continue
  ```

  Wait for the user's choice:
  - **(1) Retry:** Remove the `in_progress` (or `in_progress_batch`) entry from the state file. Set `current_item` to this item (or the first item in the batch). Proceed to the MAIN LOOP — the item(s) will be implemented fresh.
  - **(2) Skip:** Move the item(s) to the `failed` array with `"error": "Skipped by user on resume"`. Advance `current_item` to the next item after the skipped one(s). Proceed to the MAIN LOOP.
  - **(3) Mark complete:** Run `git log -1 --format="%H"` to get the current HEAD SHA. Add the item(s) to `completed` with that SHA. Update the plan file's Status field(s) to `COMPLETE [today's date]` via a subagent. Advance `current_item` to the next item. Proceed to the MAIN LOOP.

  For `in_progress_batch` (parallel items), present ALL interrupted items in the message and apply the user's choice to the entire batch.

  **If no IN_PROGRESS items found:** Report to the user: "Resuming from [current_item] in [current_phase]. [N] items already completed." Proceed directly to the MAIN LOOP.

**Step 1: Initial plan scan (subagent)**

Launch an Agent (subagent_type: "general-purpose", prompt: "...") to read `PLAN_FILE`, PROGRESS.md (if exists), and LEARNINGS.md (if exists).

Prompt the Agent to return ONLY:
- The **first incomplete phase**: phase name, all work items in that phase (item number + brief description each)
- Parallelization info for that phase: which items are independent (can run in parallel) vs which have dependencies
- A **full parallelization map** for ALL phases: for each phase, list parallel groups and sequential items (this is compact metadata, not full plan content)
- **Project context** (read from CLAUDE.md, package.json, pyproject.toml, Makefile, or similar config files):
  - `tech_stack`: primary language/framework (e.g., "TypeScript, React, Jest")
  - `test_command`: how to run tests (e.g., "npm test", "pytest")
  - `conventions`: 3-5 key conventions (e.g., "kebab-case files, ESM imports, SKILL.md uppercase")
  - `project_description`: one-sentence summary of what this project is (e.g., "A Claude Code plugin marketplace repo containing multiple plugins")
- Current progress summary (1-2 sentences)
- Total work items remaining across all phases

**Step 2: Write initial state file**

Using the subagent's response, write `.implement-plan-state.json` to the repository root:

```bash
# Write the state file (Main Agent does this directly)
cat > .implement-plan-state.json << 'EOF'
{
  "plan_file": "[PLAN_FILE path]",
  "started_at": "[current ISO timestamp]",
  "current_phase": "[first incomplete phase name]",
  "current_item": "[first item number in that phase]",
  "completed": [],
  "failed": [],
  "project_context": {
    "project_description": "[from subagent]",
    "tech_stack": "[from subagent]",
    "test_command": "[from subagent]",
    "conventions": "[from subagent]"
  },
  "last_good_sha": null,
  "checkpoints": {},
  "parallelization_map": { [from subagent — all phases] }
}
EOF
```

**Step 3: Ensure state file is gitignored**

Check if `.implement-plan-state.json` is in `.gitignore`. If not, append it:

```bash
grep -q '.implement-plan-state.json' .gitignore 2>/dev/null || echo '.implement-plan-state.json' >> .gitignore
```

If `.gitignore` was modified, stage and commit it:
```bash
git add .gitignore && git commit -m "Add .implement-plan-state.json to .gitignore"
```

**Step 4: Create task list**

Create a task list using TaskCreate to track each remaining work item in the first phase. Add metadata noting which items can run in parallel.

**Use the parallelization map from the state file for the entire execution.** When entering a phase, consult `parallelization_map` to determine which items are independent and launch them concurrently.

### MAIN LOOP — Repeat until all work items are complete:

Before each iteration, check whether the next batch of work items can be parallelized. Consult the `parallelization_map` in `.implement-plan-state.json`.

---

#### PATH A: SEQUENTIAL (single work item, or item has dependencies on incomplete items)

##### Step A0: MARK IN_PROGRESS (Main Agent — do this yourself)

Before launching the implementation subagent, mark the work item as in progress:

1. **Update state file:** Read `.implement-plan-state.json`. Set `current_item` to the item number. Add or update the item's entry: `"in_progress": { "item": "[N.M]", "phase": "[phase name]", "description": "[brief]", "started_at": "[ISO timestamp]" }`. Write the state file back.
2. **Update plan file:** Launch a quick Agent (subagent_type: "general-purpose") with this prompt:

   > In [PLAN_FILE], find work item **[N.M]** and update its `**Status:**` field from `PENDING` to `IN_PROGRESS`.
   > Return: STATUS_UPDATED when complete.

This ensures that if the session is interrupted during implementation, the resume logic can detect the incomplete work.

##### Step A1: IMPLEMENTATION (Agent)

Launch an Agent (subagent_type: "general-purpose") with this prompt:

> **Project Context:** [project_description]. Tech stack: [tech_stack]. Test command: [test_command]. Conventions: [conventions].
>
> Read [PLAN_FILE]. Implement work item: **[ITEM — phase name, item number, brief description from startup or previous iteration]**.
> Complete ALL tasks in this work item.
> When implementation is complete, also update [PLAN_FILE]: change this item's `**Status:**` field to `COMPLETE [YYYY-MM-DD]` (today's date), and add the completion date to the heading (e.g., `#### N.M Title ✅ Completed YYYY-MM-DD`).
> Return ONLY: (1) files created/modified, (2) implementation summary (max 3 sentences), (3) DONE or error description.

(Populate `[project_description]`, `[tech_stack]`, `[test_command]`, and `[conventions]` from the `project_context` object in `.implement-plan-state.json`.)

Wait for completion. Record only: files changed, success/failure status.

##### Step A2: TESTING (Agent)

Launch an Agent (subagent_type: "general-purpose") with this prompt:

> **Project Context:** [project_description]. Test command: [test_command].
>
> Run ALL project tests. If failures occur:
> 1. Diagnose root cause
> 2. Fix the issue
> 3. Re-run ALL tests
> 4. Repeat until ALL tests pass
> 5. If after 3 fix attempts the same test(s) still fail, STOP and return TESTS_STUCK with: failing test names, error messages, and what you tried.
>
> When all tests pass, return:
> - Test summary (pass count, any issues found)
> - For each issue fixed: problem, solution, prevention tip (1 line each)
> - ALL_TESTS_PASS confirmation

**If ALL_TESTS_PASS:** Proceed to Step A3. Note any issues briefly for the LEARNINGS.md update.

**If TESTS_STUCK:** The testing subagent could not fix the failures. Offer the user a rollback choice:

```text
Tests cannot be fixed for work item [N.M] after 3 attempts.
Failing: [test names from subagent]

Options:
  (1) Rollback — revert to last checkpoint [last_good_sha] and skip this item
  (2) Skip — keep the changes but mark the item as failed, continue to next item
  (3) Pause — stop execution for manual intervention
```

Wait for the user's choice:
- **(1) Rollback:** Discard all uncommitted changes with `git checkout -- .` (the failed work has not been committed, so this restores the codebase to `last_good_sha`). Then: add the item to the `failed` array in the state file with `"error": "Tests stuck — rolled back by user", "attempts": 3`. Update `current_item` to the next item. Record in LEARNINGS.md via a quick Agent. Continue to the NEXT ITERATION.
- **(2) Skip:** Add the item to the `failed` array with `"error": "Tests stuck — skipped by user", "attempts": 3`. Discard uncommitted changes with `git checkout -- .`. Update `current_item` to the next item. Continue to the NEXT ITERATION.
- **(3) Pause:** Output the failing test details and stop execution. The user can fix manually and re-run `/implement-plan` to resume from the state file.

##### Step A3: OPTIONAL DOCUMENTATION UPDATE (Main Agent — conditional)

Documentation overhead is minimized by folding the plan file update into the implementation subagent (Step A1). The remaining tracking files are updated only when warranted:

1. **PROGRESS.md** — Only update if PROGRESS.md already exists in the repo OR `--progress` flag was set. If updating, append a one-line entry: `[YYYY-MM-DD] [ITEM] — [FILES_LIST]`
2. **LEARNINGS.md** — Only update if the testing subagent (Step A2) reported actual issues that required fixes. If the tests passed clean, skip this entirely. If updating, launch a quick Agent:

   > Append to LEARNINGS.md: "[ITEM]: [ISSUE_SUMMARY] — [FIX_APPLIED]" (one line per issue).
   > Return: DOCS_UPDATED when complete.

##### Step A4: COMMIT (Main Agent — do this yourself)

Run these git commands directly:
1. `git status --short` — review changed files
2. **If `git status` shows unexpected untracked files not in the subagent's file list, warn the user and do not stage them.**
3. `git add [FILES_FROM_SUBAGENT] [PLAN_FILE]` — stage implementation files and the plan file (which the implementation subagent already updated). Also stage PROGRESS.md and/or LEARNINGS.md only if they were updated in Step A3.
4. `git commit -m "Complete [WORK_ITEM_NAME]"`
5. `git push`

##### Step A5: UPDATE STATE FILE (Main Agent — do this yourself)

After the commit succeeds, update `.implement-plan-state.json`:

1. Read the current state file
2. Remove the `in_progress` entry (the item is no longer in progress)
3. Add the completed item to `completed` array: `{ "item": "[N.M]", "phase": "[phase name]", "description": "[brief]", "status": "COMPLETE", "sha": "[commit SHA from step A4]", "files": [files changed] }`
4. Update `checkpoints` with item→SHA mapping
5. Update `last_good_sha` to the commit SHA from step A4 (this is the most recent known-good checkpoint)
6. Update `current_item` to the next item (or null if phase is complete)
7. Write the updated state file back

Mark the corresponding task as completed using TaskUpdate.

**State shedding check:** If `completed` array length is a multiple of 5, this is a shedding boundary. From this point forward, derive all context from the state file only — do not reference earlier conversation history for work item details, file lists, or error summaries.

---

#### PATH B: PARALLEL (multiple independent work items in the same phase)

Use this path when 2+ work items have no dependencies on each other. This is the **preferred path** — always check for parallelization opportunities before falling back to sequential.

##### Step B0: MARK IN_PROGRESS (Main Agent — do this yourself)

Before launching parallel implementation subagents, mark ALL items in the batch as in progress:

1. **Update state file:** Read `.implement-plan-state.json`. Add an `"in_progress_batch"` entry listing all items: `[{ "item": "[N.M]", "phase": "[phase name]", "description": "[brief]", "started_at": "[ISO timestamp]" }, ...]`. Write the state file back.
2. **Update plan file:** Launch a single Agent (subagent_type: "general-purpose") with this prompt:

   > In [PLAN_FILE], find work items **[N.M, N.N, ...]** and update each item's `**Status:**` field from `PENDING` to `IN_PROGRESS`.
   > Return: STATUS_UPDATED when complete.

##### Step B1: PARALLEL IMPLEMENTATION (Multiple Agents)

For each independent work item, launch an Agent (subagent_type: "general-purpose") with `run_in_background: true`:

> **Project Context:** [project_description]. Tech stack: [tech_stack]. Test command: [test_command]. Conventions: [conventions].
>
> Read [PLAN_FILE]. Implement work item: **[ITEM N.M — phase name, item number, brief description]**.
> Complete ALL tasks in this work item.
> When implementation is complete, also update [PLAN_FILE]: change this item's `**Status:**` field to `COMPLETE [YYYY-MM-DD]` (today's date), and add the completion date to the heading (e.g., `#### N.M Title ✅ Completed YYYY-MM-DD`).
> Return ONLY: (1) files created/modified, (2) implementation summary (max 3 sentences), (3) DONE or error description.

(Populate `[project_description]`, `[tech_stack]`, `[test_command]`, and `[conventions]` from the `project_context` object in `.implement-plan-state.json`.)

Launch ALL independent items in a **single message with multiple Agent tool calls**. This ensures true concurrent execution.

**Important constraints:**
- Maximum 3 parallel implementation subagents at once (to avoid file conflicts)
- If items touch overlapping files, run them sequentially instead
- Use TaskOutput to check background agent results; you will be notified when each completes

##### Step B2: COLLECT RESULTS

As each background Agent completes (you will be notified via TaskOutput), record for each:
- Work item name
- Files changed
- Success/failure

If any agent fails, handle its work item sequentially in a follow-up step.

##### Step B3: TESTING (Single Agent)

After ALL parallel implementations complete, launch a single testing Agent:

> **Project Context:** [project_description]. Test command: [test_command].
>
> Run ALL project tests. If failures occur:
> 1. Diagnose root cause
> 2. Fix the issue
> 3. Re-run ALL tests
> 4. Repeat until ALL tests pass
> 5. If after 3 fix attempts the same test(s) still fail, STOP and return TESTS_STUCK with: failing test names, error messages, and what you tried.
>
> When all tests pass, return:
> - Test summary (pass count, any issues found)
> - For each issue fixed: problem, solution, prevention tip (1 line each)
> - ALL_TESTS_PASS confirmation

**If ALL_TESTS_PASS:** Proceed to Step B4.

**If TESTS_STUCK:** The testing subagent could not fix the failures across the parallel batch. Offer the user a rollback choice:

```text
Tests cannot be fixed for parallel batch [N.M, N.N, ...] after 3 attempts.
Failing: [test names from subagent]

Options:
  (1) Rollback — revert all changes to last checkpoint [last_good_sha] and skip this batch
  (2) Skip — keep the changes but mark all items in the batch as failed, continue
  (3) Pause — stop execution for manual intervention
```

Wait for the user's choice:
- **(1) Rollback:** Discard all uncommitted changes with `git checkout -- .`. Add all batch items to the `failed` array with `"error": "Tests stuck — rolled back by user", "attempts": 3`. Update `current_item` to the next item after the batch. Record in LEARNINGS.md via a quick Agent. Continue to the NEXT ITERATION.
- **(2) Skip:** Add all batch items to the `failed` array with `"error": "Tests stuck — skipped by user", "attempts": 3`. Discard uncommitted changes with `git checkout -- .`. Update `current_item` to the next item after the batch. Continue to the NEXT ITERATION.
- **(3) Pause:** Output the failing test details and stop execution. The user can fix manually and re-run `/implement-plan` to resume from the state file.

##### Step B4: OPTIONAL DOCUMENTATION UPDATE (Main Agent — conditional)

Documentation overhead is minimized by folding the plan file update into each parallel implementation subagent (Step B1). The remaining tracking files are updated only when warranted:

1. **PROGRESS.md** — Only update if PROGRESS.md already exists in the repo OR `--progress` flag was set. If updating, append one-line entries for each completed item: `[YYYY-MM-DD] [ITEM] — [FILES_LIST]`
2. **LEARNINGS.md** — Only update if the testing subagent (Step B3) reported actual issues that required fixes. If the tests passed clean, skip this entirely. If updating, launch a quick Agent:

   > Append to LEARNINGS.md: for each issue encountered across the parallel batch, add "[ITEM]: [ISSUE_SUMMARY] — [FIX_APPLIED]" (one line per issue).
   > Return: DOCS_UPDATED when complete.

##### Step B5: COMMIT (Main Agent — do this yourself)

Single commit covering all parallel work items:
1. `git status --short` — review changed files
2. **If `git status` shows unexpected untracked files not in any subagent's file list, warn the user and do not stage them.**
3. `git add [ALL_FILES_FROM_ALL_SUBAGENTS] [PLAN_FILE]` — stage implementation files and the plan file (which the parallel implementation subagents already updated). Also stage PROGRESS.md and/or LEARNINGS.md only if they were updated in Step B4.
4. `git commit -m "Complete [PHASE_NAME]: [ITEM_1], [ITEM_2], [ITEM_3]"`
5. `git push`

##### Step B6: UPDATE STATE FILE (Main Agent — do this yourself)

After the commit succeeds, update `.implement-plan-state.json`:

1. Read the current state file
2. Remove the `in_progress_batch` entry (all items are no longer in progress)
3. Add ALL completed parallel items to `completed` array (one entry per item with shared SHA, each with `"status": "COMPLETE"`)
4. Update `checkpoints` with item→SHA mappings for all completed items
5. Update `last_good_sha` to the commit SHA from step B5 (this is the most recent known-good checkpoint)
6. Update `current_item` to the next item (or null if phase is complete)
7. Write the updated state file back

Mark all corresponding tasks as completed using TaskUpdate.

**State shedding check:** If `completed` array length is a multiple of 5 (or crossed a multiple of 5 with this batch), this is a shedding boundary. From this point forward, derive all context from the state file only.

---

#### NEXT ITERATION (applies to both paths)

**Primary path: Use the state file (no subagent needed)**

Read `.implement-plan-state.json` directly. Using the `completed` array, `current_phase`, and `parallelization_map`, determine the next action:

1. Identify all items in the current phase that are NOT in `completed` or `failed`
2. If items remain in the current phase, consult `parallelization_map` to determine if remaining items are parallel or sequential
3. If no items remain in the current phase, advance `current_phase` to the next phase and consult the parallelization map for that phase
4. If no phases remain, the plan is complete

Based on this analysis, determine the routing:
- `PHASE_CHANGE [new phase name] PARALLEL: [item1], [item2], [item3]` — moving to a new phase with multiple independent items
- `PHASE_CHANGE [new phase name] NEXT: [item description]` — moving to a new phase with a single/dependent item
- `PARALLEL: [item1], [item2], [item3]` — staying in the same phase with multiple independent items
- `NEXT: [item description]` — staying in the same phase with only one item or all have dependencies
- `ALL_COMPLETE` — nothing remains

**Fallback path: Subagent plan re-read (only if state file is missing or ambiguous)**

If the state file does not exist, is corrupted, or the parallelization map does not have enough information to determine next steps, launch an Agent (subagent_type: "general-purpose") to check `PLAN_FILE`:

> Read [PLAN_FILE]. List ALL remaining incomplete work items with their phase and item numbers.
> For the next batch: are any of them parallelizable (independent, no shared file dependencies)?
> Return ONLY:
> - `PHASE_CHANGE [new phase name] PARALLEL: [item1], [item2], [item3]` if moving to a new phase with multiple independent items, OR
> - `PHASE_CHANGE [new phase name] NEXT: [item description]` if moving to a new phase with a single/dependent item, OR
> - `PARALLEL: [item1], [item2], [item3]` if staying in the same phase with multiple independent items, OR
> - `NEXT: [item description]` if staying in the same phase with only one item or all have dependencies, OR
> - `ALL_COMPLETE` if nothing remains.
>
> Also return a parallelization map for ALL remaining phases so the state file can be rebuilt.

If the fallback path was used, rewrite `.implement-plan-state.json` with the updated information.

**Phase transition handling (quality gate + optional pause):**

If the routing determination (from state file or subagent fallback) indicates `PHASE_CHANGE`, run the phase boundary quality gate **before** proceeding to the next phase. This happens regardless of whether `--pause-between-phases` is set.

**Step T1: Phase Validation (Agent)**

Launch an Agent (subagent_type: "general-purpose") to validate the completed phase:

> Read [PLAN_FILE]. Find the **Phase Completion Checklist** and **Testing Requirements** sections for **[completed phase name]**.
> For each checklist item and testing requirement, verify whether it has been satisfied (marked with [x] or evidenced by work item completions).
> Cross-reference against the completed work items: [list item numbers from state file's completed array for this phase].
> Return ONLY:
> - `PHASE_VALID` if all checklist items and testing requirements are satisfied, OR
> - `PHASE_ISSUES: [list of unchecked/unsatisfied items]` if any items remain incomplete.

**Step T2: Present Phase Summary**

Display the phase summary to the user (always, regardless of flags):

```text
Phase [completed phase] complete. [M] items implemented, [F] failed/skipped.
Validation: [PHASE_VALID | PHASE_ISSUES]
[If PHASE_ISSUES: list the unchecked items]
Next up: Phase [new phase] ([N] work items).
```

**Step T3: Handle Validation Issues**

If the validation subagent returned `PHASE_ISSUES`:
1. Present the list of unchecked items to the user
2. Ask for guidance:
   ```text
   Phase [completed phase] has unchecked completion items:
   [list of issues]

   Options:
     (1) Continue anyway — proceed to the next phase despite incomplete items
     (2) Pause — stop execution to address the issues manually, then resume with /implement-plan
     (3) Abort — proceed to FINALIZATION with whatever is complete so far
   ```
3. Wait for user response:
   - **(1) Continue anyway**: log the issues to LEARNINGS.md via a quick Agent, then proceed
   - **(2) Pause**: stop execution. The user can fix issues and re-run `/implement-plan` to resume from the state file
   - **(3) Abort**: proceed to FINALIZATION

**Step T4: Phase Pause (only when `--pause-between-phases` is set)**

If `--pause-between-phases` was passed AND the phase validated successfully (PHASE_VALID or user chose "Continue anyway"):
1. **Ask the user for confirmation** before proceeding:
   ```text
   Continue to Phase [new phase]? (yes/no/skip phase/abort)
   ```
2. Wait for user response:
   - **yes**: proceed to the next phase (PATH A or PATH B as indicated)
   - **no** or **abort**: proceed to FINALIZATION with whatever is complete so far
   - **skip phase**: mark all items in the upcoming phase as skipped in the state file's `failed` array with `"error": "Phase skipped by user"`, and continue to the phase after

If `--pause-between-phases` is NOT set (default) and the phase is valid, proceed automatically to the next phase.

**Routing:**
- If **PARALLEL**: return to PATH B.
- If **NEXT**: return to PATH A.
- If **ALL_COMPLETE**: proceed to FINALIZATION.

**Do not stop early.** Continue looping until the state file (or subagent fallback) indicates ALL_COMPLETE (or the user aborts via `--pause-between-phases` confirmation). Every work item in the plan must be implemented, tested, and committed before moving to finalization.

**If execution cannot continue** (context window exhaustion, user interrupt, unfixable error, or user abort from phase gate), proceed to the COMPLETION REPORT section before stopping.

### COMPLETION REPORT (output on EVERY exit path)

Before stopping execution — whether from normal completion, early termination, user abort, or error — read `.implement-plan-state.json` and output the following report. This is the **last thing the command outputs** regardless of how it exits.

```text
═══════════════════════════════════════════════════════
 IMPLEMENTATION PROGRESS REPORT
═══════════════════════════════════════════════════════

 Status: [COMPLETE | PARTIAL — reason]
 Session started: [started_at from state file]
 Current phase: [current_phase from state file]

 ✓ Completed ([N] items):
   [For each item in completed array:]
   - [item] [description] (SHA: [first 7 chars of sha])

 ✗ Failed/Skipped ([N] items):
   [For each item in failed array:]
   - [item] [description] — [error]

 ◌ Remaining ([N] items):
   [For each item not in completed or failed:]
   - [item] [description]

 [If in_progress or in_progress_batch exists:]
 ⚠ In Progress (interrupted):
   - [item] [description] — started [started_at]

 Last checkpoint: [last_good_sha from state file] ([item number])

 To resume: /implement-plan [include --input flag if non-default path]
 The state file (.implement-plan-state.json) will resume from where this session stopped.
═══════════════════════════════════════════════════════
```

**Report generation rules:**

1. **Read the state file** — it contains `completed`, `failed`, `in_progress`/`in_progress_batch`, `current_phase`, `last_good_sha`, and `plan_file`
2. **Determine remaining items** — compare completed + failed items against the full item list from `parallelization_map` (which lists all items per phase). Items not in `completed` or `failed` are remaining.
3. **Set the Status line:**
   - `COMPLETE` — all items in completed, none remaining
   - `PARTIAL — context exhaustion` — the agent is running low on context window
   - `PARTIAL — user abort` — user chose to stop at a phase gate or confirmation prompt
   - `PARTIAL — unfixable error` — TESTS_STUCK with user choosing Pause
   - `PARTIAL — interrupted` — any other early stop
4. **Include resume guidance** — always show the `/implement-plan` command needed to resume, including any `--input` flag if the plan file is not the default path
5. **On normal completion** (ALL_COMPLETE path), the report uses `Status: COMPLETE` and the "Remaining" section shows `(none)`. The resume line is omitted.
6. **If the state file does not exist** (e.g., error before state file creation), output a minimal report: "No state file found. No work items were completed. Run `/implement-plan` to start fresh."

### FINALIZATION (only when ALL work items are complete)

#### Final Step 0: Clean Up State File

Delete the state file — it is ephemeral execution state and should not persist after the plan is complete:

```bash
rm -f .implement-plan-state.json
```

#### Final Step 1: Documentation Polish (Agent)

Launch an Agent to review and update all documentation:

> Review and update all documentation:
> - README.md: ensure accuracy, update any outdated sections
> - [PLAN_FILE]: verify all items marked complete
> - PROGRESS.md (if it exists): add completion summary at end
> - LEARNINGS.md (if it exists): synthesize all entries into a SUMMARY section at the top (max 10 bullet points)
>
> Return: DOCS_FINALIZED

#### Final Step 2: Create PR (Main Agent)

1. `git status --short` — review changed files; warn the user about any unexpected untracked files
2. `git add [PLAN_FILE] README.md` — stage these files plus PROGRESS.md and/or LEARNINGS.md only if they exist and were modified
3. `git commit -m "Polish documentation" && git push`
4. Build a descriptive PR title from the phases actually implemented (e.g., "Implement: Unified Schema, Tool API Fix, Context Management") — do NOT use a generic title like "Implementation Complete"
5. Create PR using `gh pr create` with:
   - **Title:** descriptive title from step 4
   - **Body:** summary of all phases completed, number of work items, key changes, and any learnings
6. Output the PR URL to the user

**Default behavior (no `--auto-merge` flag): STOP HERE.** The user reviews and merges the PR manually.

#### Final Step 2b: Auto-Merge (only if `--auto-merge` was specified)

If the user passed `--auto-merge`:

1. Merge the PR using `gh pr merge --squash`
2. Delete the remote branch
3. `git checkout main && git pull`

#### Final Step 3: Output (Completion Report)

Output the **COMPLETION REPORT** (defined in the COMPLETION REPORT section above) with `Status: COMPLETE`. Then add:
- PR URL (if PR-only mode) or merge confirmation (if `--auto-merge`)
- Any key learnings or issues encountered (1-3 bullet points max)

## Output Files

This command creates/updates:

| File | Purpose | When Updated |
|------|---------|--------------|
| `PLAN_FILE` (default: IMPLEMENTATION_PLAN.md) | Marks work items complete with dates | Always (updated by implementation subagent) |
| PROGRESS.md | Chronological log of completed work | Only if file already exists or `--progress` flag set |
| LEARNINGS.md | Issues encountered and solutions | Only when testing subagent reports actual issues |
| `.implement-plan-state.json` | Ephemeral execution state (gitignored, deleted on completion) | Always |

## Error Handling

### Missing Plan File

If the plan file does not exist at the resolved `PLAN_FILE` path:
```text
Error: [PLAN_FILE] not found.

Run '/plan-improvements' or '/create-plan' first to generate an implementation plan.
Or specify a custom path: /implement-plan --input <path-to-plan>
```

### Test Failures That Cannot Be Fixed (TESTS_STUCK)

If the testing subagent cannot fix failures after 3 attempts, it returns TESTS_STUCK. The orchestrator then offers rollback options:

1. **Rollback** — discard all uncommitted changes from the failed work item and skip it. The codebase returns to `last_good_sha` (the most recent successful checkpoint). Safe: no history rewriting.
2. **Skip** — discard changes and mark the item as failed, continue to the next work item.
3. **Pause** — stop execution so the user can investigate and fix manually. Resume with `/implement-plan` (picks up from state file).

The `last_good_sha` field in the state file always points to the most recent commit where all tests passed. Rollback uses `git checkout -- .` to discard uncommitted work (since failed items are never committed), preserving full git history.

### Early Termination

If execution stops before all work items are complete, the COMPLETION REPORT is output with the appropriate partial status. This covers:

1. **Context window exhaustion** — the agent detects it is running low on context. Output the report with `Status: PARTIAL — context exhaustion` and stop. The state file preserves all progress.
2. **User interrupt** — the user cancels or the session is terminated. On the next run, `/implement-plan` resumes from the state file. If the agent has an opportunity to output before stopping (e.g., user types "stop" or "abort"), output the report with `Status: PARTIAL — user abort`.
3. **Unfixable error (Pause)** — user chose "Pause" at a TESTS_STUCK prompt. Output the report with `Status: PARTIAL — unfixable error` including the failing test details.
4. **User abort at phase gate** — user chose "Abort" at a phase transition prompt or "no" at a `--pause-between-phases` confirmation. Output the report with `Status: PARTIAL — user abort`.

In all cases, the `.implement-plan-state.json` file is preserved (NOT deleted) so that `/implement-plan` can resume from where it stopped.

### Git/PR Failures

If commit or PR operations fail:
1. The error is reported to the user
2. Manual commands are provided to complete the workflow
3. Local changes are preserved

## Performance

**Typical Duration:**

| Plan Size | Expected Duration |
|-----------|------------------|
| Small (5-10 work items) | 15-30 minutes |
| Medium (10-20 work items) | 30-60 minutes |
| Large (20-40 work items) | 1-2 hours |
| Very Large (40+ work items) | 2+ hours |

**Factors Affecting Performance:**

- Work item complexity
- Test suite size and duration
- Number of test failures to fix
- Documentation update scope

**Signs of Abnormal Behavior:**

- Same work item attempted more than 3 times
- Testing subagent in fix loop for more than 10 iterations
- No progress after 15 minutes

**If the command seems stuck:**

1. Check the task list for current status
2. Look for testing loop messages
3. Review PROGRESS.md for last successful work item
4. Consider interrupting and re-running — the command will resume from `.implement-plan-state.json` (picks up at the last incomplete work item)

## Example Usage

```yaml
# Default: PR-only (no merge)
User: /implement-plan

Claude: Starting implementation plan execution...

[Spawns startup subagent to read plan]

Found 12 work items across 3 phases.
Current progress: 0/12 complete
Starting with Phase 1, Item 1.1: Add input validation to CLI parser

[Spawns implementation subagent]
...
Implementation complete. Files modified: src/cli.ts, src/validators.ts

[Spawns testing subagent]
...
All tests pass (47 passed, 0 failed)

[Spawns documentation subagent]
...
Documentation updated.

[Commits: "Complete Phase 1, Item 1.1: Add input validation to CLI parser"]

Moving to Phase 1, Item 1.2...
...

[After all items complete]

All 12 work items implemented successfully.
Created PR: "Implement: Input Validation, Error Handling, CLI Parser"
PR URL: https://github.com/owner/repo/pull/42

Implementation complete — 12 work items across 3 phases, all tested and documented.
Review and merge the PR when ready.
```

```yaml
# With --auto-merge: creates PR then merges automatically
User: /implement-plan --auto-merge

Claude: Starting implementation plan execution...
...
[Same workflow as above]
...
Created and merged PR: "Implement: Input Validation, Error Handling, CLI Parser"
Checked out main branch.

Implementation complete — 12 work items across 3 phases, all tested and documented.
```

```yaml
# With --input: use a plan file at a custom path
User: /implement-plan --input docs/migration-plan.md

Claude: Starting implementation plan execution...
Reading plan from: docs/migration-plan.md
...
[Same workflow as default, but reads from the specified path]
```

```yaml
# With --pause-between-phases: interactive phase-by-phase execution
User: /implement-plan --pause-between-phases

Claude: Starting implementation plan execution...
...
[Completes all Phase 1 work items]

Phase 1 (Input Validation) complete. 4 items implemented, 0 failed/skipped.
Validation: PHASE_VALID
Next up: Phase 2 (Error Handling) (4 work items).
Continue to Phase 2? (yes/no/skip phase/abort)

User: yes

[Continues with Phase 2...]
```

```yaml
# Combined flags
User: /implement-plan --input plans/refactor.md --pause-between-phases --auto-merge
```

## Related Commands

- `/plan-improvements` - Generate IMPLEMENTATION_PLAN.md from codebase analysis
- `/create-plan` - Generate IMPLEMENTATION_PLAN.md from requirements documents
- `/plan-next` - Get recommendation for next action
- `/test-project` - Run comprehensive test workflow

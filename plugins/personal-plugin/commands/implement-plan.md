---
description: Execute IMPLEMENTATION_PLAN.md using orchestrated subagents with automatic testing, documentation, and git workflow
allowed-tools: Agent, Bash(git:*), Bash(gh:*), Bash(npm:*), Bash(npx:*), Bash(yarn:*), Bash(pnpm:*), Bash(pytest:*), Bash(python:*), Bash(jest:*), Bash(vitest:*), Bash(bun:*), Task
---

# Implement Plan Command

Execute an IMPLEMENTATION_PLAN.md file by orchestrating subagents in a loop. Each work item is implemented, tested, documented, and committed by dedicated subagents while the main agent retains only minimal state — preserving context window capacity for long-running plans.

## Input Validation

**Optional Arguments:**

| Argument | Default | Description |
|----------|---------|-------------|
| `--input <path>` | `IMPLEMENTATION_PLAN.md` | Path to the plan file. Supports absolute or relative paths. Use this when the plan was generated to a non-default location (e.g., `/create-plan --output docs/plan.md`). |
| `--auto-merge` | `false` | When set, automatically merge the PR and clean up the branch after all work items are complete. Without this flag, the command creates a PR and stops. |
| `--pause-between-phases` | `false` | When set, pause and ask the user for confirmation before starting each new phase. Useful for reviewing progress or adjusting the plan mid-execution. |

**Argument Resolution:**

At startup, resolve the plan file path:
1. If `--input <path>` was provided, use that path (resolve relative paths against the repository root)
2. Otherwise, default to `IMPLEMENTATION_PLAN.md` in the repository root
3. Store the resolved path as `PLAN_FILE` — use this variable in ALL subsequent references to the plan file

**Prerequisites Validation:**

Before executing the plan, verify:
1. `PLAN_FILE` exists at the resolved path
2. Current branch is NOT main or master
3. Working directory is clean (no uncommitted changes)
4. GitHub CLI (gh) is authenticated

**If the plan file is missing:**
```text
Error: [PLAN_FILE] not found.

Run one of these commands to generate an implementation plan:
- /plan-improvements — Generate from codebase analysis
- /create-plan — Generate from requirements documents

Or specify a custom path: /implement-plan --input <path-to-plan>
```

**If on main/master:**
```text
Error: Cannot run on main/master branch.

Create a feature branch first:
  git checkout -b feature/implementation
```

**If working directory is dirty:**
```text
Error: Uncommitted changes detected.

Commit or stash your changes before running this command:
  git status
  git add <files> && git commit -m "Message"
```

## Overview

This command automates the execution of a phased implementation plan by:

1. Reading the plan and tracking progress
2. Implementing each work item via subagents
3. Running tests and fixing failures
4. Updating documentation (PROGRESS.md, LEARNINGS.md)
5. Committing after each work item
6. Creating a PR when complete (merge only with `--auto-merge`)

## Prerequisites

Before running this command, ensure:

- **Plan file** exists at the expected path (default: `IMPLEMENTATION_PLAN.md` in repo root, or custom path via `--input`). Generated by `/plan-improvements` or `/create-plan`.
- You are on a feature branch (not main/master)
- Working directory is clean (no uncommitted changes)
- GitHub CLI (gh) is authenticated

## Execution Strategy

### Context Window Discipline

**This is the most important principle.** Large plans can span dozens of work items. If the main agent reads files, holds implementation details, or accumulates subagent output, the context window fills up and the agent loses coherence before the plan completes.

**Rules:**

| Do | Do Not |
|----|--------|
| Delegate ALL file reading to subagents | Read the plan file or source files directly |
| Retain only: status, files changed, errors | Ask subagents to return file contents |
| Use TaskCreate/TaskUpdate for progress tracking (not subagent launching) | Hold work item details in conversational memory |
| Spawn fresh subagents for each step | Reuse subagent context across work items |
| Launch parallel subagents with `run_in_background: true` | Wait for one item to finish before starting an independent one |
| Batch documentation updates for parallel items | Spawn a doc subagent for each parallel item separately |
| Use a single commit for parallel batches | Create individual commits for each parallel item |

### Orchestration Pattern

The main agent acts as a **thin loop controller** — it decides what to do next, spawns subagents to do it, records outcomes in 1-2 sentences, and moves on. All heavy lifting (reading files, writing code, running tests, updating docs) happens inside subagents whose context is discarded after they return.

**Parallel-first execution:** When the plan marks work items as parallelizable (same phase, no inter-dependencies), launch multiple implementation subagents concurrently using `run_in_background: true`. This dramatically reduces total execution time.

### Workflow Per Work Item

For each incomplete work item in the plan file (`PLAN_FILE`):

1. **Implementation Subagent**: Reads the plan and implements the work item
2. **Testing Subagent**: Runs all tests, fixes failures until all pass
3. **Documentation Subagent**: Updates `PLAN_FILE`, PROGRESS.md, LEARNINGS.md
4. **Main Agent**: Commits and pushes changes

**Parallel variant** (for independent work items within the same phase):

1. **Launch N implementation subagents concurrently** (one per independent work item, `run_in_background: true`)
2. **Collect results** as each completes — check output files for status
3. **Single testing subagent** runs full test suite after all parallel items complete
4. **Single documentation subagent** updates tracking files for all completed items at once
5. **Main Agent**: Single commit covering all parallel work items, then push

### Finalization

When all work items are complete:

1. Polish all documentation
2. Create PR with title "Implementation Complete"
3. Merge PR and clean up branch

## Instructions

Follow these steps exactly. Use the **Agent tool** to spawn subagents (with `subagent_type: "general-purpose"` and `prompt: "..."`). Use **TaskCreate/TaskUpdate/TaskList** only for progress tracking — they do NOT launch subagents. After each subagent returns, retain only the minimal summary described — discard everything else.

### STARTUP (do this ONCE at the beginning)

Launch an Agent (subagent_type: "general-purpose", prompt: "...") to read `PLAN_FILE`, PROGRESS.md (if exists), and LEARNINGS.md (if exists).

Prompt the Agent to return ONLY:
- A list of ALL remaining incomplete work items grouped by phase (phase name, item number, brief description each)
- For each phase: which work items are parallelizable (independent of each other)
- Current progress summary (1-2 sentences)
- Total work items remaining

Create a task list using TaskCreate to track each remaining work item. Add metadata noting which items can run in parallel.

**Use this parallelization map for the entire execution.** When entering a phase, check which items are independent and launch them concurrently.

### MAIN LOOP — Repeat until all work items are complete:

Before each iteration, check whether the next batch of work items can be parallelized. Use the parallelization map from STARTUP.

---

#### PATH A: SEQUENTIAL (single work item, or item has dependencies on incomplete items)

##### Step A1: IMPLEMENTATION (Agent)

Launch an Agent (subagent_type: "general-purpose") with this prompt:

> Read [PLAN_FILE]. Implement work item: **[ITEM — phase name, item number, brief description from startup or previous iteration]**.
> Complete ALL tasks in this work item.
> Return ONLY: (1) files created/modified, (2) implementation summary (max 3 sentences), (3) DONE or error description.

Wait for completion. Record only: files changed, success/failure status.

##### Step A2: TESTING (Agent)

Launch an Agent (subagent_type: "general-purpose") with this prompt:

> Run ALL project tests. If failures occur:
> 1. Diagnose root cause
> 2. Fix the issue
> 3. Re-run ALL tests
> 4. Repeat until ALL tests pass
>
> When all tests pass, return:
> - Test summary (pass count, any issues found)
> - For each issue fixed: problem, solution, prevention tip (1 line each)
> - ALL_TESTS_PASS confirmation

Wait for ALL_TESTS_PASS. If issues were fixed, note them briefly for the LEARNINGS.md update.

##### Step A3: DOCUMENTATION UPDATE (Agent)

Launch an Agent (subagent_type: "general-purpose") with this prompt:

> Update project tracking files:
> 1. [PLAN_FILE] — Mark **[WORK_ITEM]** as complete with today's date
> 2. PROGRESS.md — Append entry: date, work item completed, files changed: **[FILES_LIST]**
> 3. LEARNINGS.md — Append any testing issues: **[ISSUES_IF_ANY]**
>
> Return: DOCS_UPDATED when complete.

##### Step A4: COMMIT (Main Agent — do this yourself)

Run these git commands directly:
1. `git status --short` — review changed files
2. **If `git status` shows unexpected untracked files not in the subagent's file list, warn the user and do not stage them.**
3. `git add [FILES_FROM_SUBAGENT] [PLAN_FILE] PROGRESS.md LEARNINGS.md` — stage only the files reported by subagents plus tracking files (omit PROGRESS.md/LEARNINGS.md if they were not updated)
4. `git commit -m "Complete [WORK_ITEM_NAME]"`
5. `git push`

Mark the corresponding task as completed using TaskUpdate.

---

#### PATH B: PARALLEL (multiple independent work items in the same phase)

Use this path when 2+ work items have no dependencies on each other. This is the **preferred path** — always check for parallelization opportunities before falling back to sequential.

##### Step B1: PARALLEL IMPLEMENTATION (Multiple Agents)

For each independent work item, launch an Agent (subagent_type: "general-purpose") with `run_in_background: true`:

> Read [PLAN_FILE]. Implement work item: **[ITEM N.M — phase name, item number, brief description]**.
> Complete ALL tasks in this work item.
> Return ONLY: (1) files created/modified, (2) implementation summary (max 3 sentences), (3) DONE or error description.

Launch ALL independent items in a **single message with multiple Agent tool calls**. This ensures true concurrent execution.

**Important constraints:**
- Maximum 3 parallel implementation subagents at once (to avoid file conflicts)
- If items touch overlapping files, run them sequentially instead
- Use TaskOutput to check background agent results; you will be notified when each completes

##### Step B2: COLLECT RESULTS

As each background Agent completes (you will be notified via TaskOutput), record for each:
- Work item name
- Files changed
- Success/failure

If any agent fails, handle its work item sequentially in a follow-up step.

##### Step B3: TESTING (Single Agent)

After ALL parallel implementations complete, launch a single testing Agent:

> Run ALL project tests. If failures occur:
> 1. Diagnose root cause
> 2. Fix the issue
> 3. Re-run ALL tests
> 4. Repeat until ALL tests pass
>
> When all tests pass, return:
> - Test summary (pass count, any issues found)
> - For each issue fixed: problem, solution, prevention tip (1 line each)
> - ALL_TESTS_PASS confirmation

##### Step B4: DOCUMENTATION UPDATE (Single Agent)

Launch a single Agent to update tracking for ALL completed parallel items at once:

> Update project tracking files:
> 1. [PLAN_FILE] — Mark these work items as complete with today's date: **[LIST_OF_ITEMS]**
> 2. PROGRESS.md — Append entries for each: date, work item completed, files changed: **[FILES_PER_ITEM]**
> 3. LEARNINGS.md — Append any testing issues: **[ISSUES_IF_ANY]**
>
> Return: DOCS_UPDATED when complete.

##### Step B5: COMMIT (Main Agent — do this yourself)

Single commit covering all parallel work items:
1. `git status --short` — review changed files
2. **If `git status` shows unexpected untracked files not in any subagent's file list, warn the user and do not stage them.**
3. `git add [ALL_FILES_FROM_ALL_SUBAGENTS] [PLAN_FILE] PROGRESS.md LEARNINGS.md` — stage only the files reported by all parallel subagents plus tracking files (omit PROGRESS.md/LEARNINGS.md if they were not updated)
4. `git commit -m "Complete [PHASE_NAME]: [ITEM_1], [ITEM_2], [ITEM_3]"`
5. `git push`

Mark all corresponding tasks as completed using TaskUpdate.

---

#### NEXT ITERATION (applies to both paths)

Launch an Agent (subagent_type: "general-purpose") to check `PLAN_FILE`:

> Read [PLAN_FILE]. List ALL remaining incomplete work items with their phase and item numbers.
> For the next batch: are any of them parallelizable (independent, no shared file dependencies)?
> Return ONLY:
> - `PHASE_CHANGE [new phase name] PARALLEL: [item1], [item2], [item3]` if moving to a new phase with multiple independent items, OR
> - `PHASE_CHANGE [new phase name] NEXT: [item description]` if moving to a new phase with a single/dependent item, OR
> - `PARALLEL: [item1], [item2], [item3]` if staying in the same phase with multiple independent items, OR
> - `NEXT: [item description]` if staying in the same phase with only one item or all have dependencies, OR
> - `ALL_COMPLETE` if nothing remains.

**Phase transition handling (when `--pause-between-phases` is set):**

If the subagent response starts with `PHASE_CHANGE` and the user passed `--pause-between-phases`:
1. Display a summary of the phase just completed (items done, any issues)
2. Display the upcoming phase name and its work items
3. **Ask the user for confirmation** before proceeding:
   ```text
   Phase [completed phase] finished. Next up: Phase [new phase] ([N] work items).
   Continue? (yes/no/skip phase/abort)
   ```
4. Wait for user response:
   - **yes**: proceed to the next phase (PATH A or PATH B as indicated)
   - **no** or **abort**: proceed to FINALIZATION with whatever is complete so far
   - **skip phase**: mark all items in the upcoming phase as skipped and continue to the phase after

If `--pause-between-phases` is NOT set (default), ignore `PHASE_CHANGE` prefixes and proceed automatically.

**Routing:**
- If **PARALLEL**: return to PATH B.
- If **NEXT**: return to PATH A.
- If **ALL_COMPLETE**: proceed to FINALIZATION.

**Do not stop early.** Continue looping until the subagent confirms ALL_COMPLETE (or the user aborts via `--pause-between-phases` confirmation). Every work item in the plan must be implemented, tested, and committed before moving to finalization.

### FINALIZATION (only when ALL work items are complete)

#### Final Step 1: Documentation Polish (Agent)

Launch an Agent to review and update all documentation:

> Review and update all documentation:
> - README.md: ensure accuracy, update any outdated sections
> - [PLAN_FILE]: verify all items marked complete
> - PROGRESS.md: add completion summary at end
> - LEARNINGS.md: synthesize all entries into a SUMMARY section at the top (max 10 bullet points)
>
> Return: DOCS_FINALIZED

#### Final Step 2: Create PR (Main Agent)

1. `git status --short` — review changed files; warn the user about any unexpected untracked files
2. `git add [PLAN_FILE] PROGRESS.md LEARNINGS.md README.md` — stage only the documentation files that were updated (omit any not modified)
3. `git commit -m "Polish documentation" && git push`
4. Build a descriptive PR title from the phases actually implemented (e.g., "Implement: Unified Schema, Tool API Fix, Context Management") — do NOT use a generic title like "Implementation Complete"
5. Create PR using `gh pr create` with:
   - **Title:** descriptive title from step 4
   - **Body:** summary of all phases completed, number of work items, key changes, and any learnings
6. Output the PR URL to the user

**Default behavior (no `--auto-merge` flag): STOP HERE.** The user reviews and merges the PR manually.

#### Final Step 2b: Auto-Merge (only if `--auto-merge` was specified)

If the user passed `--auto-merge`:

1. Merge the PR using `gh pr merge --squash`
2. Delete the remote branch
3. `git checkout main && git pull`

#### Final Step 3: Output

Report completion to the user with:
- Summary of what was implemented (phases, work item count)
- PR URL (if PR-only mode) or merge confirmation (if `--auto-merge`)
- Any learnings or issues encountered

## Output Files

This command creates/updates:

| File | Purpose |
|------|---------|
| `PLAN_FILE` (default: IMPLEMENTATION_PLAN.md) | Marks work items complete with dates |
| PROGRESS.md | Chronological log of completed work |
| LEARNINGS.md | Issues encountered and solutions |

## Error Handling

### Missing Plan File

If the plan file does not exist at the resolved `PLAN_FILE` path:
```text
Error: [PLAN_FILE] not found.

Run '/plan-improvements' or '/create-plan' first to generate an implementation plan.
Or specify a custom path: /implement-plan --input <path-to-plan>
```

### Test Failures That Cannot Be Fixed

If a test failure cannot be resolved after multiple attempts:
1. The testing subagent will report the specific failure
2. The orchestrator will pause and ask for guidance
3. User can choose to skip, provide context, or abort

### Git/PR Failures

If commit or PR operations fail:
1. The error is reported to the user
2. Manual commands are provided to complete the workflow
3. Local changes are preserved

## Performance

**Typical Duration:**

| Plan Size | Expected Duration |
|-----------|------------------|
| Small (5-10 work items) | 15-30 minutes |
| Medium (10-20 work items) | 30-60 minutes |
| Large (20-40 work items) | 1-2 hours |
| Very Large (40+ work items) | 2+ hours |

**Factors Affecting Performance:**

- Work item complexity
- Test suite size and duration
- Number of test failures to fix
- Documentation update scope

**Signs of Abnormal Behavior:**

- Same work item attempted more than 3 times
- Testing subagent in fix loop for more than 10 iterations
- No progress after 15 minutes

**If the command seems stuck:**

1. Check the task list for current status
2. Look for testing loop messages
3. Review PROGRESS.md for last successful work item
4. Consider interrupting and re-running — the command will pick up from the last incomplete work item

## Example Usage

```yaml
# Default: PR-only (no merge)
User: /implement-plan

Claude: Starting implementation plan execution...

[Spawns startup subagent to read plan]

Found 12 work items across 3 phases.
Current progress: 0/12 complete
Starting with Phase 1, Item 1.1: Add input validation to CLI parser

[Spawns implementation subagent]
...
Implementation complete. Files modified: src/cli.ts, src/validators.ts

[Spawns testing subagent]
...
All tests pass (47 passed, 0 failed)

[Spawns documentation subagent]
...
Documentation updated.

[Commits: "Complete Phase 1, Item 1.1: Add input validation to CLI parser"]

Moving to Phase 1, Item 1.2...
...

[After all items complete]

All 12 work items implemented successfully.
Created PR: "Implement: Input Validation, Error Handling, CLI Parser"
PR URL: https://github.com/owner/repo/pull/42

Implementation complete — 12 work items across 3 phases, all tested and documented.
Review and merge the PR when ready.
```

```yaml
# With --auto-merge: creates PR then merges automatically
User: /implement-plan --auto-merge

Claude: Starting implementation plan execution...
...
[Same workflow as above]
...
Created and merged PR: "Implement: Input Validation, Error Handling, CLI Parser"
Checked out main branch.

Implementation complete — 12 work items across 3 phases, all tested and documented.
```

```yaml
# With --input: use a plan file at a custom path
User: /implement-plan --input docs/migration-plan.md

Claude: Starting implementation plan execution...
Reading plan from: docs/migration-plan.md
...
[Same workflow as default, but reads from the specified path]
```

```yaml
# With --pause-between-phases: interactive phase-by-phase execution
User: /implement-plan --pause-between-phases

Claude: Starting implementation plan execution...
...
[Completes all Phase 1 work items]

Phase 1 (Input Validation) finished. Next up: Phase 2 (Error Handling) (4 work items).
Continue? (yes/no/skip phase/abort)

User: yes

[Continues with Phase 2...]
```

```yaml
# Combined flags
User: /implement-plan --input plans/refactor.md --pause-between-phases --auto-merge
```

## Related Commands

- `/plan-improvements` - Generate IMPLEMENTATION_PLAN.md from codebase analysis
- `/create-plan` - Generate IMPLEMENTATION_PLAN.md from requirements documents
- `/plan-next` - Get recommendation for next action
- `/test-project` - Run comprehensive test workflow

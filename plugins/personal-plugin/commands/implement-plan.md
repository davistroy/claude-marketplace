---
description: Execute IMPLEMENTATION_PLAN.md using orchestrated subagents with automatic testing, documentation, and git workflow
allowed-tools: Bash(git:*), Bash(gh:*), Task, Skill
---

# Implement Plan Command

Execute an IMPLEMENTATION_PLAN.md file by orchestrating subagents in a loop. Each work item is implemented, tested, documented, and committed by dedicated subagents while the main agent retains only minimal state — preserving context window capacity for long-running plans.

## Overview

This command automates the execution of a phased implementation plan by:

1. Reading the plan and tracking progress
2. Implementing each work item via subagents
3. Running tests and fixing failures
4. Updating documentation (PROGRESS.md, LEARNINGS.md)
5. Committing after each work item
6. Creating and merging a PR when complete

## Prerequisites

Before running this command, ensure:

- **IMPLEMENTATION_PLAN.md** exists in the repository root (generated by `/plan-improvements` or `/create-plan`)
- You are on a feature branch (not main/master)
- Working directory is clean (no uncommitted changes)
- GitHub CLI (gh) is authenticated

## Execution Strategy

### Context Window Discipline

**This is the most important principle.** Large plans can span dozens of work items. If the main agent reads files, holds implementation details, or accumulates subagent output, the context window fills up and the agent loses coherence before the plan completes.

**Rules:**

| Do | Do Not |
|----|--------|
| Delegate ALL file reading to subagents | Read IMPLEMENTATION_PLAN.md or source files directly |
| Retain only: status, files changed, errors | Ask subagents to return file contents |
| Use TaskCreate/TaskUpdate to track progress | Hold work item details in conversational memory |
| Spawn fresh subagents for each step | Reuse subagent context across work items |

### Orchestration Pattern

The main agent acts as a **thin loop controller** — it decides what to do next, spawns a subagent to do it, records the outcome in 1-2 sentences, and moves on. All heavy lifting (reading files, writing code, running tests, updating docs) happens inside subagents whose context is discarded after they return.

### Workflow Per Work Item

For each incomplete work item in IMPLEMENTATION_PLAN.md:

1. **Implementation Subagent**: Reads the plan and implements the work item
2. **Testing Subagent**: Runs all tests, fixes failures until all pass
3. **Documentation Subagent**: Updates IMPLEMENTATION_PLAN.md, PROGRESS.md, LEARNINGS.md
4. **Main Agent**: Commits and pushes changes

### Finalization

When all work items are complete:

1. Polish all documentation
2. Create PR with title "Implementation Complete"
3. Merge PR and clean up branch

## Instructions

Follow these steps exactly. Use the **Task tool** to spawn subagents. After each subagent returns, retain only the minimal summary described — discard everything else.

### STARTUP (do this ONCE at the beginning)

Spawn a subagent (subagent_type: "general-purpose") to read IMPLEMENTATION_PLAN.md, PROGRESS.md (if exists), and LEARNINGS.md (if exists).

Prompt the subagent to return ONLY:
- The next incomplete work item (phase name, item number, brief description)
- Current progress summary (1-2 sentences)
- Total work items remaining

Create a task list using TaskCreate to track each remaining work item.

### MAIN LOOP — Repeat until all work items are complete:

#### Step 1: IMPLEMENTATION (Subagent A)

Spawn a subagent (subagent_type: "general-purpose") with this prompt:

> Read IMPLEMENTATION_PLAN.md. Implement work item: **[ITEM — phase name, item number, brief description from startup or previous iteration]**.
> Complete ALL tasks in this work item.
> Return ONLY: (1) files created/modified, (2) implementation summary (max 3 sentences), (3) DONE or error description.

Wait for completion. Record only: files changed, success/failure status.

#### Step 2: TESTING (Subagent B)

Spawn a subagent (subagent_type: "general-purpose") with this prompt:

> Run ALL project tests. If failures occur:
> 1. Diagnose root cause
> 2. Fix the issue
> 3. Re-run ALL tests
> 4. Repeat until ALL tests pass
>
> When all tests pass, return:
> - Test summary (pass count, any issues found)
> - For each issue fixed: problem, solution, prevention tip (1 line each)
> - ALL_TESTS_PASS confirmation

Wait for ALL_TESTS_PASS. If issues were fixed, note them briefly for the LEARNINGS.md update.

#### Step 3: DOCUMENTATION UPDATE (Subagent C)

Spawn a subagent (subagent_type: "general-purpose") with this prompt:

> Update project tracking files:
> 1. IMPLEMENTATION_PLAN.md — Mark **[WORK_ITEM]** as complete with today's date
> 2. PROGRESS.md — Append entry: date, work item completed, files changed: **[FILES_LIST]**
> 3. LEARNINGS.md — Append any testing issues: **[ISSUES_IF_ANY]**
>
> Return: DOCS_UPDATED when complete.

#### Step 4: COMMIT (Main Agent — do this yourself)

Run these git commands directly:
1. `git add -A`
2. `git commit -m "Complete [WORK_ITEM_NAME]"`
3. `git push`

Mark the corresponding task as completed using TaskUpdate.

#### Step 5: NEXT ITERATION

Spawn a subagent (subagent_type: "general-purpose") to check IMPLEMENTATION_PLAN.md:

> Is there any incomplete work item? Return ONLY: `NEXT: [item description]` OR `ALL_COMPLETE`

- If **NEXT**: return to Step 1 with the new item.
- If **ALL_COMPLETE**: proceed to FINALIZATION.

**Do not stop early.** Continue looping until the subagent confirms ALL_COMPLETE. Every work item in the plan must be implemented, tested, and committed before moving to finalization.

### FINALIZATION (only when ALL work items are complete)

#### Final Step 1: Documentation Polish (Subagent)

Spawn a subagent to review and update all documentation:

> Review and update all documentation:
> - README.md: ensure accuracy, update any outdated sections
> - IMPLEMENTATION_PLAN.md: verify all items marked complete
> - PROGRESS.md: add completion summary at end
> - LEARNINGS.md: synthesize all entries into a SUMMARY section at the top (max 10 bullet points)
>
> Return: DOCS_FINALIZED

#### Final Step 2: PR and Merge (Main Agent)

1. `git add -A && git commit -m "Polish documentation" && git push`
2. Create PR with title "Implementation Complete" and body summarizing phases completed
3. Merge the PR and delete the branch
4. Checkout main and pull

#### Final Step 3: Output

Report completion to the user with a summary of what was implemented.

## Output Files

This command creates/updates:

| File | Purpose |
|------|---------|
| IMPLEMENTATION_PLAN.md | Marks work items complete with dates |
| PROGRESS.md | Chronological log of completed work |
| LEARNINGS.md | Issues encountered and solutions |

## Error Handling

### Missing IMPLEMENTATION_PLAN.md

If IMPLEMENTATION_PLAN.md does not exist:
```
Error: IMPLEMENTATION_PLAN.md not found in repository root.

Run '/plan-improvements' or '/create-plan' first to generate an implementation plan.
```

### Test Failures That Cannot Be Fixed

If a test failure cannot be resolved after multiple attempts:
1. The testing subagent will report the specific failure
2. The orchestrator will pause and ask for guidance
3. User can choose to skip, provide context, or abort

### Git/PR Failures

If commit or PR operations fail:
1. The error is reported to the user
2. Manual commands are provided to complete the workflow
3. Local changes are preserved

## Performance

**Typical Duration:**

| Plan Size | Expected Duration |
|-----------|------------------|
| Small (5-10 work items) | 15-30 minutes |
| Medium (10-20 work items) | 30-60 minutes |
| Large (20-40 work items) | 1-2 hours |
| Very Large (40+ work items) | 2+ hours |

**Factors Affecting Performance:**

- Work item complexity
- Test suite size and duration
- Number of test failures to fix
- Documentation update scope

**Signs of Abnormal Behavior:**

- Same work item attempted more than 3 times
- Testing subagent in fix loop for more than 10 iterations
- No progress after 15 minutes

**If the command seems stuck:**

1. Check the task list for current status
2. Look for testing loop messages
3. Review PROGRESS.md for last successful work item
4. Consider interrupting and re-running — the command will pick up from the last incomplete work item

## Example Usage

```
User: /implement-plan

Claude: Starting implementation plan execution...

[Spawns startup subagent to read plan]

Found 12 work items across 3 phases.
Current progress: 0/12 complete
Starting with Phase 1, Item 1.1: Add input validation to CLI parser

[Spawns implementation subagent]
...
Implementation complete. Files modified: src/cli.ts, src/validators.ts

[Spawns testing subagent]
...
All tests pass (47 passed, 0 failed)

[Spawns documentation subagent]
...
Documentation updated.

[Commits: "Complete Phase 1, Item 1.1: Add input validation to CLI parser"]

Moving to Phase 1, Item 1.2...
...

[After all items complete]

All 12 work items implemented successfully.
Creating PR: "Implementation Complete"
PR merged. Checked out main branch.

Implementation complete — 12 work items across 3 phases, all tested and documented.
```

## Related Commands

- `/plan-improvements` - Generate IMPLEMENTATION_PLAN.md from codebase analysis
- `/create-plan` - Generate IMPLEMENTATION_PLAN.md from requirements documents
- `/plan-next` - Get recommendation for next action
- `/test-project` - Run comprehensive test workflow
